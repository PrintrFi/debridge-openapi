/*
 * deBridge Liquidity Network (DLN) API
 *
 * A turnkey solution for a high-performance cross-chain trading<br><br><a href=\"https://docs.debridge.finance/dln-the-debridge-liquidity-network-protocol/interacting-with-the-api/quick-start-guide\">Quick Start Guide</a>
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`dln_order_controller_v10_cancel_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10CancelOrderError {
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dln_order_controller_v10_create_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10CreateOrderError {
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dln_order_controller_v10_ext_call_cancel_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10ExtCallCancelOrderError {
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dln_order_controller_v10_get_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10GetOrderError {
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dln_order_controller_v10_get_order_ids_by_tx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10GetOrderIdsByTxError {
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dln_order_controller_v10_get_order_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DlnOrderControllerV10GetOrderStatusError {
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// This endpoint generates a transaction that cancels the given order. This transaction must be published to the destination chain of the order. Unlocked funds would be transferred to the address specified as the orderAuthority of the given order on the source chain. This transaction can only be executed by th orderAuthority of the given order on the destination chain
pub async fn dln_order_controller_v10_cancel_order(configuration: &configuration::Configuration, id: &str) -> Result<models::DlnOrderCancelTxResponse, Error<DlnOrderControllerV10CancelOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/v1.0/dln/order/{id}/cancel-tx", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderCancelTxResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderCancelTxResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10CancelOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint returns the data for a transaction to place a cross-chain DLN order.
pub async fn dln_order_controller_v10_create_order(configuration: &configuration::Configuration, src_chain_id: &str, src_chain_token_in: &str, src_chain_token_in_amount: &str, dst_chain_id: &str, dst_chain_token_out: &str, dst_chain_token_out_amount: Option<&str>, additional_taker_reward_bps: Option<i32>, src_intermediary_token_address: Option<&str>, dst_intermediary_token_address: Option<&str>, dst_intermediary_token_spender_address: Option<&str>, intermediary_token_usd_price: Option<f64>, dst_chain_token_out_recipient: Option<&str>, sender_address: Option<&str>, src_chain_order_authority_address: Option<&str>, src_allowed_cancel_beneficiary: Option<&str>, referral_code: Option<&str>, affiliate_fee_percent: Option<f64>, affiliate_fee_recipient: Option<&str>, src_chain_token_in_sender_permit: Option<&str>, dst_chain_order_authority_address: Option<&str>, enable_estimate: Option<bool>, allowed_taker: Option<&str>, external_call: Option<&str>, dln_hook: Option<&str>, prepend_operating_expenses: Option<bool>, metadata: Option<&str>, otc: Option<bool>, ptp: Option<bool>, skip_solana_recipient_validation: Option<bool>, src_chain_priority_level: Option<&str>) -> Result<models::DlnOrderControllerV10CreateOrder200Response, Error<DlnOrderControllerV10CreateOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_src_chain_id = src_chain_id;
    let p_src_chain_token_in = src_chain_token_in;
    let p_src_chain_token_in_amount = src_chain_token_in_amount;
    let p_dst_chain_id = dst_chain_id;
    let p_dst_chain_token_out = dst_chain_token_out;
    let p_dst_chain_token_out_amount = dst_chain_token_out_amount;
    let p_additional_taker_reward_bps = additional_taker_reward_bps;
    let p_src_intermediary_token_address = src_intermediary_token_address;
    let p_dst_intermediary_token_address = dst_intermediary_token_address;
    let p_dst_intermediary_token_spender_address = dst_intermediary_token_spender_address;
    let p_intermediary_token_usd_price = intermediary_token_usd_price;
    let p_dst_chain_token_out_recipient = dst_chain_token_out_recipient;
    let p_sender_address = sender_address;
    let p_src_chain_order_authority_address = src_chain_order_authority_address;
    let p_src_allowed_cancel_beneficiary = src_allowed_cancel_beneficiary;
    let p_referral_code = referral_code;
    let p_affiliate_fee_percent = affiliate_fee_percent;
    let p_affiliate_fee_recipient = affiliate_fee_recipient;
    let p_src_chain_token_in_sender_permit = src_chain_token_in_sender_permit;
    let p_dst_chain_order_authority_address = dst_chain_order_authority_address;
    let p_enable_estimate = enable_estimate;
    let p_allowed_taker = allowed_taker;
    let p_external_call = external_call;
    let p_dln_hook = dln_hook;
    let p_prepend_operating_expenses = prepend_operating_expenses;
    let p_metadata = metadata;
    let p_otc = otc;
    let p_ptp = ptp;
    let p_skip_solana_recipient_validation = skip_solana_recipient_validation;
    let p_src_chain_priority_level = src_chain_priority_level;

    let uri_str = format!("{}/v1.0/dln/order/create-tx", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("srcChainId", &p_src_chain_id.to_string())]);
    req_builder = req_builder.query(&[("srcChainTokenIn", &p_src_chain_token_in.to_string())]);
    req_builder = req_builder.query(&[("srcChainTokenInAmount", &p_src_chain_token_in_amount.to_string())]);
    req_builder = req_builder.query(&[("dstChainId", &p_dst_chain_id.to_string())]);
    req_builder = req_builder.query(&[("dstChainTokenOut", &p_dst_chain_token_out.to_string())]);
    if let Some(ref param_value) = p_dst_chain_token_out_amount {
        req_builder = req_builder.query(&[("dstChainTokenOutAmount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_taker_reward_bps {
        req_builder = req_builder.query(&[("additionalTakerRewardBps", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src_intermediary_token_address {
        req_builder = req_builder.query(&[("srcIntermediaryTokenAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dst_intermediary_token_address {
        req_builder = req_builder.query(&[("dstIntermediaryTokenAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dst_intermediary_token_spender_address {
        req_builder = req_builder.query(&[("dstIntermediaryTokenSpenderAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_intermediary_token_usd_price {
        req_builder = req_builder.query(&[("intermediaryTokenUSDPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dst_chain_token_out_recipient {
        req_builder = req_builder.query(&[("dstChainTokenOutRecipient", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sender_address {
        req_builder = req_builder.query(&[("senderAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src_chain_order_authority_address {
        req_builder = req_builder.query(&[("srcChainOrderAuthorityAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src_allowed_cancel_beneficiary {
        req_builder = req_builder.query(&[("srcAllowedCancelBeneficiary", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_referral_code {
        req_builder = req_builder.query(&[("referralCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_affiliate_fee_percent {
        req_builder = req_builder.query(&[("affiliateFeePercent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_affiliate_fee_recipient {
        req_builder = req_builder.query(&[("affiliateFeeRecipient", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src_chain_token_in_sender_permit {
        req_builder = req_builder.query(&[("srcChainTokenInSenderPermit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dst_chain_order_authority_address {
        req_builder = req_builder.query(&[("dstChainOrderAuthorityAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_enable_estimate {
        req_builder = req_builder.query(&[("enableEstimate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allowed_taker {
        req_builder = req_builder.query(&[("allowedTaker", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_external_call {
        req_builder = req_builder.query(&[("externalCall", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dln_hook {
        req_builder = req_builder.query(&[("dlnHook", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_prepend_operating_expenses {
        req_builder = req_builder.query(&[("prependOperatingExpenses", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_metadata {
        req_builder = req_builder.query(&[("metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_otc {
        req_builder = req_builder.query(&[("otc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ptp {
        req_builder = req_builder.query(&[("ptp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_solana_recipient_validation {
        req_builder = req_builder.query(&[("skipSolanaRecipientValidation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src_chain_priority_level {
        req_builder = req_builder.query(&[("srcChainPriorityLevel", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderControllerV10CreateOrder200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderControllerV10CreateOrder200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10CreateOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint generates a transaction that cancels external call in the given order. 
pub async fn dln_order_controller_v10_ext_call_cancel_order(configuration: &configuration::Configuration, id: &str) -> Result<models::DlnOrderCancelTxResponse, Error<DlnOrderControllerV10ExtCallCancelOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/v1.0/dln/order/{id}/extcall-cancel-tx", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderCancelTxResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderCancelTxResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10ExtCallCancelOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint returns the data of order.
pub async fn dln_order_controller_v10_get_order(configuration: &configuration::Configuration, id: &str) -> Result<models::DlnOrderResponse, Error<DlnOrderControllerV10GetOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/v1.0/dln/order/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10GetOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint returns the status of order.
pub async fn dln_order_controller_v10_get_order_ids_by_tx(configuration: &configuration::Configuration, hash: &str) -> Result<models::DlnOrderidsByTxResponse, Error<DlnOrderControllerV10GetOrderIdsByTxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_hash = hash;

    let uri_str = format!("{}/v1.0/dln/tx/{hash}/order-ids", configuration.base_path, hash=crate::apis::urlencode(p_hash));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderidsByTxResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderidsByTxResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10GetOrderIdsByTxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint returns the status of order.
pub async fn dln_order_controller_v10_get_order_status(configuration: &configuration::Configuration, id: &str) -> Result<models::DlnOrderStatusResponse, Error<DlnOrderControllerV10GetOrderStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/v1.0/dln/order/{id}/status", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DlnOrderStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DlnOrderStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DlnOrderControllerV10GetOrderStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

